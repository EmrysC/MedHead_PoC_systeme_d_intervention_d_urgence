pipeline {
    agent any
    
    triggers {
        pollSCM('H/5 * * * *')
    }

    environment {
        COMPOSE_DIR = "Poc/Poc/src/main/resources"
    }

    stages {


        stage('Initialisation Workspace') {
            steps {
                echo 'Récupération du fichier .env depuis les secrets Jenkins...'
                withCredentials([file(credentialsId: 'medhead-env-file', variable: 'ENV_FILE')]) {
                    // On crée le fichier avant que docker-compose ne soit appelé
                    sh "cp \$ENV_FILE ${COMPOSE_DIR}/.env"
                }
            }
        }
 
        stage('Compilation') {
            steps {
                echo 'Génération du nouveau JAR...'
                dir("Poc/Poc") {
                    sh "mvn clean package -DskipTests"
                }
            }
        }

        stage('Nettoyage & Préparation') {
            steps {
                echo 'Nettoyage sélectif (sans toucher à Jenkins)...'
                
                // 1. On arrête uniquement les services de test et l'app
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml stop app db newman-db-cleaner"
                
                // 2. On supprime les conteneurs et les volumes associés (-v) pour ces services uniquement
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml rm -f -v app db newman-db-cleaner"
                
                // 3. On relance la DB et les outils 
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml up -d db sonarqube newman-db-cleaner"
            }
        }

        stage('Lancement Application') {
            steps {
                echo 'Construction de l image et démarrage de l application...'
                dir("${COMPOSE_DIR}") {
                    sh "docker-compose -f compose.yaml --env-file .env up -d --build app"
                }
                echo 'Attente de stabilisation (30s)...'
                sleep 30 // Temps nécessaire pour que Spring Boot et la sécurité soient opérationnels
            }
        }

        stage('Configuration Webhook SonarQube') {
            steps {
                echo 'Création du Webhook dans SonarQube via API...'
                // On utilise le réseau Docker interne (sonarqube-poc:9000)
                // L'URL de retour pointe vers le conteneur Jenkins (jenkins_poc:8080)
                sh """
                    curl -u admin:admin -X POST "http://sonarqube-poc:9000/api/webhooks/create?name=Jenkins-Webhook&url=http://jenkins_poc:8080/sonarqube-webhook/" || echo "Le webhook existe déjà ou SonarQube est indisponible."
                """
            }
        }


        stage('Analyse (SonarQube)') {
            steps {
                echo 'Lancement du scan avec le scanner interne (Dossier Partagé Jenkins)...'
                
                // On se place là où Maven a compilé le projet
                dir("Poc/Poc") { 
                    
                    // On utilise le serveur configuré automatiquement 
                    withSonarQubeEnv('sonarqube-poc') { 
                        // ON UTILISE LE SCANNER  DOCKERFILE 
                        sh """
                            sonar-scanner \
                            -Dsonar.projectKey=MedHead_PoC \
                            -Dsonar.projectName=MedHead_PoC_System \
                            -Dsonar.host.url=http://sonarqube-poc:9000 \
                            -Dsonar.login=admin \
                            -Dsonar.password=admin \
                            -Dsonar.sources=src/main/java \
                            -Dsonar.java.binaries=target/classes \
                            -Dsonar.exclusions=**/target/**,**/*.env
                        """
                    }

                    // Jenkins trouvera le rapport 
                    timeout(time: 5, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                }
            }
        }


        stage('Set jeu de données pour tests') {
            steps {
                echo 'Injection manuelle des fichiers et lancement des tests...'
                dir("${COMPOSE_DIR}") {

                    // 1. INJECTION DE IMPORT.SQL (Pour remplir la base vide)
                    echo 'Importation des données initiales (import.sql)...'
                    sh "docker cp sql-init/import.sql newman-db-cleaner:/tmp/import.sql"
                    sh "docker exec newman-db-cleaner sh -c 'mariadb -h db -u root -pexample poc_db < /tmp/import.sql'"

                    // 2. INJECTION DE CLEAN_DB.SQL (Pour préparer les cas d'erreur Newman)
                    echo 'Préparation des scénarios de tests (clean_db.sql)...'
                    sh "docker cp api_tests_newman/clean_db.sql newman-db-cleaner:/tmp/clean_db.sql"
                    sh "docker exec newman-db-cleaner sh -c 'mariadb -h db -u root -pexample poc_db < /tmp/clean_db.sql'"
                    
                    sleep 10 // Petit délai pour s'assurer que le cleaner a fini

                }
            }
        }

        /*/ Newman fonctionne correctement commenter pour l'instant pour se concentrer sur les E2E
        stage('Tests API (Newman)') {
            steps {
                echo 'Injection manuelle des fichiers et lancement des tests...'
                dir("${COMPOSE_DIR}") {

                    // 1. Préparation de Newman (Injection des tests JSON)
                    // On crée le conteneur sans le lancer pour y copier les fichiers
                    sh "docker-compose create newman"
                    sh "docker cp api_tests_newman/collection.json newman-api-tests:/etc/newman/collection.json"
                    sh "docker cp api_tests_newman/env.json newman-api-tests:/etc/newman/env.json"
                    
                    // 2. Exécution de Newman
                    // -a permet d'afficher la sortie dans la console Jenkins
                    sh "docker start -a newman-api-tests"
                }
            }
        }
        */

        /*/ E2E Selenium fonctionne correctement commenter pour l'instant pour se concentrer sur sonarcube
        stage('Tests E2E (Selenium)') {
            steps {
                echo 'Mise à jour et lancement des tests...'
                
                // Reconstruit de l image de test pour intégrer vos dernières modifs GitHub
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml build e2e-reservation"

                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    // Montage sur /tmp/output pour extraire les images vers Jenkins
                    sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml run --rm -v \$(pwd):/tmp/output e2e-reservation node E2E_connexion_clicSpecialite_Selection_SaisieAdresse_reservation.js"
                }

                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml run --rm -v \$(pwd):/tmp/output e2e-reservation node E2E_connexion_RechercheSpecialite_clicSpecialite_Selection_ClicGPS_reservation.js"
                }
            }
        }
        */

    }
    post {
        always {
            echo 'Archivage des rapports et nettoyage...'
            // 1 Récupère toutes les captures d'écran (.png) générées pendant les tests
            archiveArtifacts artifacts: '*.png', allowEmptyArchive: true
            // 2. On stoppe d'abord (Docker a besoin du .env pour identifier les services)

            sleep 10 // Petit délai pour s'assurer que tout est bien fini avant le stop

            sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml stop app db newman-db-cleaner"
            // 3. On supprime le secret ensuite
            sh "rm -f ${COMPOSE_DIR}/.env"
        }
    }
}