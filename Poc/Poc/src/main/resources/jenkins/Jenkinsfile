pipeline {
    agent any
    
    triggers {
        pollSCM('H/5 * * * *')
    }

    environment {
        COMPOSE_DIR = "Poc/Poc/src/main/resources"
    }

    stages {

        stage('Initialisation Workspace') {
            steps {
                echo 'Récupération du secret et vérification...'
                // 1. On COPIE le fichier depuis le stockage interne de Jenkins 
                sh "cp /var/jenkins_home/.env ${COMPOSE_DIR}/.env"
                
                // 2. On VÉRIFIE que le fichier est bien arrivé au bon endroit
                dir("${COMPOSE_DIR}") {
                    sh "test -f .env && echo 'Succès : .env injecté.' || (echo 'ERREUR : .env toujours absent' && exit 1)"
                }
            }
        }

        stage('Nettoyage & Préparation') {
            steps {
                echo 'Redémarrage des services applicatifs...'
                // On ne stoppe que l'app et la db pour garder SonarQube "chaud" (plus rapide)
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml stop app db"
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml rm -f app db"
                // up -d s'assure que tout tourne sans réinitialiser Sonar s'il est déjà là
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml up -d db app sonarqube"
            }
        }

        stage('Compilation') {
            steps {
                echo 'Compilation du projet avec le Maven de Jenkins...'
                // On se déplace dans le dossier contenant le fichier pom.xml (Poc/Poc)
                dir("Poc/Poc") {
                    sh "mvn clean compile"
                }
            }
        }

        stage('Lancement Application') {
            steps {
                echo 'Démarrage avec lecture directe du fichier .env par Docker...'
                dir("${COMPOSE_DIR}") {
                    sh "docker-compose --env-file .env up -d app"
                }

                echo 'Attente de stabilisation (30s)...'
                sleep 30
            }
        }

        stage('Analyse SonarQube') {
            steps {
                echo 'Lancement du scan...'
                sh """
                    docker-compose -f ${COMPOSE_DIR}/compose.yaml run --rm \
                    sonar-scanner \
                    -Dsonar.projectKey=MedHead_PoC \
                    -Dsonar.projectName=MedHead_PoC_System \
                    -Dsonar.host.url=http://sonarqube-poc:9000 \
                    -Dsonar.login=admin \
                    -Dsonar.password=admin \
                    -Dsonar.sources=. \
                    -Dsonar.java.binaries=. \
                    -Dsonar.exclusions=**/target/**,**/*.env
                """
            }
        }


        stage('Tests API (Newman)') {
            steps {
                echo 'Injection manuelle des fichiers et lancement des tests...'
                dir("${COMPOSE_DIR}") {

                    // 1. INJECTION DE IMPORT.SQL (Pour remplir la base vide)
                    echo 'Importation des données initiales (import.sql)...'
                    sh "docker cp sql-init/import.sql newman-db-cleaner:/tmp/import.sql"
                    sh "docker exec newman-db-cleaner sh -c 'mariadb -h db -u root -pexample poc_db < /tmp/import.sql'"

                    // 2. INJECTION DE CLEAN_DB.SQL (Pour préparer les cas d'erreur Newman)
                    echo 'Préparation des scénarios de tests (clean_db.sql)...'
                    sh "docker cp api_tests_newman/clean_db.sql newman-db-cleaner:/tmp/clean_db.sql"
                    sh "docker exec newman-db-cleaner sh -c 'mariadb -h db -u root -pexample poc_db < /tmp/clean_db.sql'"
                    
                    sleep 10 // Petit délai pour s'assurer que le cleaner a fini

                    // 3. Préparation de Newman (Injection des tests JSON)
                    // On crée le conteneur sans le lancer pour y copier les fichiers
                    sh "docker-compose create newman"
                    sh "docker cp api_tests_newman/collection.json newman-api-tests:/etc/newman/collection.json"
                    sh "docker cp api_tests_newman/env.json newman-api-tests:/etc/newman/env.json"
                    
                    // 4. Exécution de Newman
                    // -a permet d'afficher la sortie dans la console Jenkins
                    sh "docker start -a newman-api-tests"
                }
            }
        }

/*
        stage('Tests API (Newman)') {
            steps {
                echo 'Nettoyage DB et lancement Newman...'
                dir("${COMPOSE_DIR}") {
                    // On lance les commandes sans forcer le -v, 
                    sh "docker-compose run --rm newman-db-cleaner"
                    sh "docker-compose run --rm newman"
                }
            }
        }
*/
        stage('Tests E2E') {
            steps {
                echo 'Lancement des scénarios Selenium...'
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml run --rm e2e-reservation"
                sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml run --rm e2e-autre-test"
            }
        }
    }

    post {
        always {
            echo 'Nettoyage final...'
            // 1. On stoppe d'abord (Docker a besoin du .env pour identifier les services)
            sh "docker-compose -f ${COMPOSE_DIR}/compose.yaml stop app db"
            // 2. On supprime le secret ensuite
            sh "rm -f ${COMPOSE_DIR}/.env"
        }
    }
}